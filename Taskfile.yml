# https://taskfile.dev

version: "3"

tasks:
  ##########################################
  # Database
  psql:
    desc: Start a postgres shell
    cmds:
      - docker-compose exec postgres psql

  psql-pipe:
    desc: Start a postgres shell for piping commands into
    cmds:
      - docker-compose exec -T postgres psql

  dump-db:
    desc: Create a database dump. Can specify the filename with FILENAME.
    cmds:
      - docker-compose exec -T postgres pg_dump --format custom --compress 9 --dbname dashboard > '{{.FILENAME}}'
    vars:
      TIMESTAMP:
        sh: date --utc +"%Y-%m-%dT%H:%M:%SZ"
      DEFAULT_FILENAME: "dashboard-db-{{.TIMESTAMP}}.dump"
      FILENAME: "{{default .DEFAULT_FILENAME .FILENAME}}"

  restore-db:
    desc: Restore a database dump. Need to specify filename with FILENAME.
    preconditions:
      - sh: "[[ '{{.FILENAME}}' != '<no value>' ]]"
        msg: "FILENAME is not set"
    cmds:
      - docker-compose exec -T postgres pg_restore --clean --if-exists --single-transaction --dbname dashboard < '{{.FILENAME}}'

  migrate-db:
    desc: Migrates the db using "migrate"
    cmds:
      - task: run-migrate
        vars:
          CLI_ARGS: up

  new-migration:
    desc: Creates a new migration file. Can set NAME to name it.
    cmds:
      - migrate create -ext sql -dir migrations -seq -digits 4 '{{default "new_migration" .NAME}}'

  run-migrate:
    desc: Runs the "migrate" tool while passing on any command line arguments after --
    cmds:
      - migrate -database "postgresql:///?sslmode=disable" -path migrations {{.CLI_ARGS}}

  # Not doing this as a migration as there is no easy access to environment variables there
  create-readonly-postgres-user:
    desc: Creates a readonly user called "grafana"
    preconditions:
      - sh: "[[ '{{.DASH_PGPASSWORD_GRAFANA}}' != '<no value>' ]]"
        msg: "DASH_PGPASSWORD_GRAFANA is not set"
      - sh: "[[ '{{.DASH_PGDATABASE}}' != '<no value>' ]]"
        msg: "DASH_PGDATABASE is not set"
    cmds:
      - |-
        SQL="
          CREATE USER grafana WITH PASSWORD '$DASH_PGPASSWORD_GRAFANA';

          GRANT CONNECT ON DATABASE $DASH_PGDATABASE TO grafana;
          GRANT USAGE ON SCHEMA public TO grafana;
          GRANT SELECT ON ALL TABLES IN SCHEMA public TO grafana;

          -- Grant the SELECT privilege on all new tables
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO grafana;
        "
        docker-compose exec -T postgres psql --command "$SQL"

  generate-initial-ssl-cert:
    desc: >-
      Request the initial letsencrypt certifacte for DASH_DOMAIN.
      Refreshing it will be handled by the acme.sh service.
    preconditions:
      - sh: "[[ '{{.DASH_DOMAIN}}' != '<no value>' ]]"
        msg: "DASH_DOMAIN is not set"
    cmds:
      # start nginx with a temporary self-signed certificate (which gets autogenerated on startup)
      # (we need nginx to host the acme challange at http://$DASH_DOMAIN/.well-known/acme-challenge/)
      - |-
        docker-compose up -d acme.sh
        docker-compose up --build --force-recreate -d nginx
      # request the certificate
      - |-
        docker-compose exec acme.sh --issue --domain "{{.DASH_DOMAIN}}" --webroot /acme.sh-webroot --force
        docker-compose exec acme.sh --install-cert --domain "{{.DASH_DOMAIN}}" --key-file /certs/key.pem \
            --fullchain-file /certs/cert.pem
      # reload nginx config to use the issued certificate
      - |-
        docker-compose exec nginx nginx -s reload
        # for easier checking if nginx is coming up
        sleep 1
        docker-compose logs nginx
